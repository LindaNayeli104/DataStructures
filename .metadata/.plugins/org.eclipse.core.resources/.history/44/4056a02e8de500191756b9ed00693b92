import java.util.LinkedList;
import java.util.NoSuchElementException;

public class MyHashTable<K,V> {    //Con Direccionamiento por Encadenamiento             //Arreglos, Listas enlazadas, Genericos
	private LinkedList<MyNodoHT<K,V>>[] tabla;          //Tabla de listas enlazadas con nodos(nodos hash tables)
	private int size;
	private static final double loadFactor = 0.75;
	
	public MyHashTable(){
		this.tabla = (LinkedList<MyNodoHT<K,V>>[])new LinkedList[11];    //**********  Dijo que no se podia declarar un array a partir de genericos
		for(int i=0; i<this.tabla.length;i++) {
			this.tabla[i] = new LinkedList<>();   //********** Cuando se pone solo los <>
		}
		this.size = 0;
	}
	
	public void put(K llave, V valor) {   // rehasing = rehacer
		if(((double) this.size) / this.tabla.length > MyHashTable.loadFactor) {
			rehasing();
		}
		int pos = Math.abs(llave.hashCode()) % this.tabla.length;  // % da un res:  entre 0 y n-1
		this.tabla[pos].add(new MyNodoHT<K,V>(llave, valor));
		this.size++;
	}
	
	
	private void rehasing() {  
		LinkedList<MyNodoHT<K,V>>[] t_temp = this.tabla;  
		
		this.tabla= (LinkedList<MyNodoHT<K,V>>[])new LinkedList[this.tabla.length*2+1];
		
		for(int i=0; i<this.tabla.length;i++) {
			this.tabla[i] = new LinkedList<>();   
		}
		
		for(int i=0; i<t_temp.length;i++) {
			while(!t_temp[i].isEmpty()) {
				put(t_temp[i].getFirst().llave,t_temp
						[i].getFirst().valor);
				t_temp[i].removeFirst();
			}
		}	
	}
	
	public V get(K llave) {
		int pos = Math.abs(llave.hashCode()) % this.tabla.length;  
		try {
		for(MyNodoHT<K,V> nodo : tabla[pos]) {
			if(nodo.llave.equals(llave)) {
				return nodo.valor;
			}	
		}
		throw new Exception();
		}catch(Exception ex) {
			throw new NoSuchElementException("No se encontró el elemento asociado a esa llave");
		}
	}
	
	public V remove(K llave) {
		int pos = Math.abs(llave.hashCode()) % this.tabla.length;  
		V res;
		try {
			for(MyNodoHT<K,V> nodo : tabla[pos]) {
				if(nodo.llave.equals(llave)) {
					res = nodo.valor;
					tabla[pos].remove(nodo);
					return res;
				}	
			}
			throw new Exception();
			}catch(Exception ex) {
				throw new NoSuchElementException("No se encontró el elemento asociado a esa llave");
			}
		
	}
	
	
/*	
	public V remove (K llave) {
		//Boorsa de la tabla el elemento que tiene esa llave y regresa el valor asociado
		//Si la llave no esta arrojada NoSuchElementException
	}
	
*/
	
	//get(llave)   : valor                        Se va a lista a la posicion a donde deberia estar guardada la
	//												llave, voy a iterra la lista y vere si en alguna elemento esta guardado
	//												la llave y regre algo, sino no un no such element exception
	//			puedo usar un for each / Iterador --->  For mejorado
	
	//private rehasing() : Incrementa el tamaño de la lista al doble+1  cuando se exceda el loadFactor
	//containsKey : Boolena si la llave esta en la HT
	
			//
	//remove                 buscar elemento y si borrarlo y si no arrojar excecion 
	
	
	//Al insertar primero se hace el reharsing 
	
	public static void main(String[] args) {
		MyHashTable<String, Integer> ht = new MyHashTable<String, Integer>();
		
		ht.put("a", 1);
		ht.put("b", 2);
		ht.put("c", 3);
		ht.put("d", 4);
		ht.put("e", 5);
		ht.put("f", 6);
		ht.put("g", 7);
		ht.put("h", 8);
		ht.put("i", 9);
		ht.put("j", 10);
		ht.put("k", 11);
		
		for(int i=0; i< ht.tabla.length;i++) {
			System.out.println(ht.tabla[i]);
		}
		
		//System.out.println(ht.get("k"));
		System.out.println(ht.remove("k"));
	}
	
	
	

}



class MyNodoHT<K,V> {
	K llave;
	V valor;
	
	public MyNodoHT(K llave, V valor){
		this.llave = llave;
		this.valor = valor;
	}
	
	public String toString() {
		return "Key: " + this.llave + ", value:" + this.valor; 
	}
	
}


//CointainsValue es dificil
